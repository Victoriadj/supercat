#!/usr/bin/env python
"""
The referi module
"""
import argparse
import os
import importlib
import random
from supercat.utils import *
from importlib.util import spec_from_file_location
from datetime import datetime
try:
    import pygame
    from pygame.locals import *
    PYGAME_MODULE = True
except ImportError:
    print ('pygame module not available')
    PYGAME_MODULE = False

default_players = tuple(map(
    lambda x:x.split('.')[0],
    filter(
        lambda x:x.endswith('.py'),
        os.listdir('players')
    )
))

class PlayerAction(argparse.Action):
    """Return a module"""
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        if nargs is not None:
            raise ValueError("nargs not allowed")
        super(PlayerAction, self).__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        player = importlib.import_module('players.' + values)

        setattr(namespace, self.dest, player)



def main(player1=None, player2=None, fps=1, coin=False, capture_screen=False, no_render=False):
    render = not no_render
    if PYGAME_MODULE and render:
        pygame.init()
        screen = pygame.display.set_mode((395, 395))
        pygame.display.set_caption('Supercat referi')
        clock = pygame.time.Clock()
        board = pygame.image.load('src/board.png')
        icons = {
            "X": pygame.image.load('src/square.png'),
            "O": pygame.image.load('src/circle.png'),
        }
        big_icons = {
            "X": pygame.image.load('src/square_big.png'),
            "O": pygame.image.load('src/circle_big.png'),
            "R": pygame.image.load('src/octo_big.png'),
        }

    print ('Begining the game...')

    if player1.__name__ == player2.__name__:
        name = player1.__name__.split('.')[-1]
        assigns = {
            "X": name+'1',
            "O": name+'2',
        }
    else:
        assigns = {
            "X": player1.__name__.split('.')[-1],
            "O": player2.__name__.split('.')[-1],
        }

    pieces = ["X", "O", "R"]
    players = [player1, player2]
    world = clean_world()

    turn = False
    move = 1
    game_should_play = None
    winner = 'R'

    if coin and random.choice([0, 1]) == 1:
        print ('Flipping the coin...')
        players.reverse()
        pieces[0], pieces[1] = pieces[1], pieces[0]

    print ('%s starts game'%assigns[pieces[turn]])

    while True:
        if PYGAME_MODULE and render:
            for event in pygame.event.get():
                if event.type == KEYDOWN and event.key == 27:
                    # ESC key, exit game
                    return
                elif event.type == QUIT:
                    # Handles window close button
                    return
        # Make the player play
        game, pos = players[turn].play(
            world.copy(),
            game_should_play,
            pieces[turn],
            move,
        )

        # Handle surrenders
        if game is None:
            print ("%s surrenders!"%assigns[pieces[turn]])
            break

        # Player made an invalid move
        if game_should_play is not None and game_should_play != game:
            print ("%s did not play the game he should!"%assigns[pieces[turn]])
            break

        if world[game]['owner'] in pieces:
            print ("%s attempted to play in a closed game!"%assigns[pieces[turn]])
            break

        # Not available boxes
        if world[game][pos] in pieces:
            print ("%a attempted to play an already played box!"%assigns[pieces[turn]])
            break

        print (move, assigns[pieces[turn]], game, pos)

        # Set the world to the new status
        world[game][pos] = pieces[turn]

        if is_owned(world[game]):
            world[game]['owner'] = pieces[turn]
            print ("%s owned game %s"%(assigns[pieces[turn]], game))

        if is_dead_heat(world[game]):
            world[game]['owner'] = 'R'
            print ("%s killed the heat %s"%(assigns[pieces[turn]], game))

        if won_game(world):
            print ("%s wins!"%assigns[pieces[turn]])
            winner = assigns[pieces[turn]]
            break

        elif is_dead_world(world):
            print ("Game finished without a winner")
            break

        game_should_play = pos if world[pos]['owner'] is None else None

        if PYGAME_MODULE and render:
            # Paint the board
            screen.fill((255, 255, 255))
            screen.blit(board, (0, 0))

            # Paint the game status
            for g_row in range(3):
                for g_col in range(3):
                    if world[g_row, g_col]['owner'] in pieces:
                        # draw a big one
                        coordinates = g_row*(105+30) + 10, g_col*(105 + 30) + 10
                        screen.blit(big_icons[world[g_row, g_col]['owner']], coordinates)
                        continue

                    for row in range(3):
                        for col in range(3):
                            if world[g_row, g_col][row, col] in pieces:
                                # draw a small one
                                coordinates = g_row*(105+30) + row*(25 + 15) + 10, g_col*(105 + 30) + col*(25 + 15) + 10
                                screen.blit(icons[world[g_row, g_col][row, col]], coordinates)

            pygame.display.flip()

        turn = not turn
        move += 1

        if PYGAME_MODULE and render:
            # tick to 1 fps
            clock.tick(fps)

    if capture_screen and PYGAME_MODULE and render:
        pygame.image.save(screen, "screenshot_%s.png"%datetime.now().strftime('%Y-%m-%dT%H-%M-%S'))

    return winner

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog="referi",
        description='Supercat referi',
        epilog="""
        lets play!
        """
    )
    parser.add_argument(
        'player1',
        metavar='PLAYER',
        type=str,
        help='first player',
        action=PlayerAction,
        choices=default_players,
    )
    parser.add_argument(
        'player2',
        metavar='PLAYER',
        type=str,
        help='second player',
        action=PlayerAction,
        choices=default_players,
    )
    parser.add_argument(
        '-f', '--fps',
        metavar='NUM',
        type=int,
        help='fps at with the game should play',
        default=1,
    )
    parser.add_argument(
        '-c', '--coin',
        action='store_true',
        help='should the referi flip a coin?',
        default=False,
    )
    parser.add_argument(
        '-s', '--capture-screen',
        action='store_true',
        help='take a screenshot of the final game',
        default=False,
    )
    parser.add_argument(
        '-n', '--no-render',
        action='store_true',
        help='Do not render the pygame GUI, just compute the game',
        default=False,
    )

    args = parser.parse_args()

    main(**vars(args))
